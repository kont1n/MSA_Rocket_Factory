name: Test Coverage

on:
  workflow_call:
    inputs:
      modules:
        required: true
        type: string
      go-version:
        required: true
        type: string
      golangci-lint-version:
        required: true
        type: string

jobs:
  test:
    name: test
    runs-on: ubuntu-latest
    timeout-minutes: 10

    permissions:
      contents: write
      pages: write

    steps:
      # tests
      - name: Checkout code
        uses: actions/checkout@v4.2.2

      - name: Install Go
        uses: actions/setup-go@v5.4.0
        with:
          go-version: ${{ inputs.go-version }}

      - name: Verify dependencies
        run: go mod verify

      - name: Restore cache
        uses: actions/cache@v4.2.0
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-v1-go-${{ hashFiles('go.work.sum') }}
          restore-keys: |
            ${{ runner.os }}-v1-go-

      - name: Check and install dependencies
        run: |
          # Находим все go.mod файлы и выполняем go mod tidy в каждой директории
          find . -name "go.mod" -type f | while read -r modfile; do
            dir=$(dirname "$modfile")
            echo "Processing module in: $dir"
            cd "$dir"
            go mod tidy
            cd - > /dev/null
          done
          
          # Проверяем изменения в go.mod и go.sum файлах
          git diff --exit-code **/go.mod
          git diff --exit-code **/go.sum

      - name: Install gocov-html
        run: |
          go install github.com/axw/gocov/gocov@v1
          go install github.com/matm/gocov-html/cmd/gocov-html@v1

      - name: Run tests
        run: |
          mkdir -p .github_pages
          
          # Создаем общий файл покрытия
          echo "mode: atomic" > coverage.out
          
          # Запускаем тесты во всех модулях и объединяем результаты
          while IFS= read -r modfile; do
            dir=$(dirname "$modfile")
            echo "Running tests in: $dir"
            cd "$dir"
            
            # Запускаем тесты и добавляем результаты в общий файл
            go test ./... -coverprofile=tmp_coverage.out -covermode=atomic -coverpkg=./...
            if [ -f tmp_coverage.out ]; then
              # Пропускаем первую строку (mode: atomic) и добавляем остальное
              # Используем относительные пути от корня проекта
              awk 'NR>1' tmp_coverage.out >> ../../coverage.out
              rm tmp_coverage.out
            fi
            
            cd - > /dev/null
          done < <(find . -name "go.mod" -type f)
          
          # Генерируем отчеты
          go tool cover -func=coverage.out -o=cover.out
          gocov convert coverage.out | gocov-html > .github_pages/index.html

      # pages
      - name: Setup Pages
        uses: actions/configure-pages@v5
        with:
          enablement: true

      - name: Upload Artifact for Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: .github_pages/

      - name: Upload Coverage Report as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            .github_pages/
            coverage.out
            cover.out
          retention-days: 30

      # badge
      - name: Update coverage Badge
        uses: tj-actions/coverage-badge-go@v2
        with:
          text: Coverage_Report
          target: README.md
          filename: cover.out
          link: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}
        continue-on-error: true

      - name: Verify Changed files
        uses: tj-actions/verify-changed-files@v12
        id: verify-changed-files
        with:
          files: README.md

      - name: Commit changes
        if: steps.verify-changed-files.outputs.files_changed == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add README.md
          git commit -m "chore: Updated coverage badge."

      - name: Push changes
        if: steps.verify-changed-files.outputs.files_changed == 'true'
        run: |
          git remote set-url origin https://x-access-token:${{ github.token }}@github.com/${{ github.repository }}.git
          git push origin HEAD:${{ github.ref_name }}

  coverage:
    needs: test
    runs-on: ubuntu-latest
    timeout-minutes: 10

    permissions:
      contents: write
      pages: write
      id-token: write

    environment:
      name: github-pages

    steps:
      - name: Deploy coverage report to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        continue-on-error: true

      - name: Check deployment status
        if: steps.deployment.outcome == 'success'
        run: |
          echo "✅ Coverage report successfully deployed to GitHub Pages"
          echo "📊 Report available at: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"

      - name: Deployment failed notice
        if: steps.deployment.outcome == 'failure'
        run: |
          echo "⚠️ GitHub Pages deployment failed"
          echo "📋 Coverage report is available as an artifact: coverage-report"
          echo "🔧 To enable GitHub Pages:"
          echo "   1. Go to repository Settings > Pages"
          echo "   2. Select 'GitHub Actions' as source"
          echo "   3. Re-run this workflow"